\chapter{Булева алгебра регулярных языков}
\label{Chapter5}

\section{Свойства регулярных языков}
\label{Chapter5PropsReg}

Регулярные (а значит, и автоматные, и ПЛ-) языки обладают большим 
количеством интересных свойств, многие из которых легко доказываются на 
основе соответствия между упомянутыми классами языков.

Второе свойство регулярных языков, которое мы рассмотрим, назовем 
свойством замкнутости относительно теоретико"/множественных операций. 
Иначе, можно сказать, что регулярные множества представляют собой 
подалгебру алгебры всех подмножеств $\Sigma^*$.

\begin{mytheorem} Класс регулярных языков замкнут относительно 
операций: объединения, конкатенации, итерации, дополнения, пересечения, 
разности. \end{mytheorem}

\begin{myproof}Для регулярных языков $L_1$, $L_2$ рассмотрим описывающие
их регулярные выражения $\RE(L_1)$, $\RE(L_2)$. Язык объединения
(соответственно, конкатенации, итерации) описывается выражением $\RE(L_1) +
\RE(L_2)$ (соответственно, $\RE(L_1)\RE(L_2)$, $\RE(L_1)^\ast$), а значит,
регулярен.

Для регулярного языка $L$ построим распознающий его
детерминированный конечный автомат $\mathcal A(L)$, задаваемый пятеркой $(Q, \Sigma, \delta, q_0, F)$. Легко
проверить, что автомат $\widetilde{\mathcal A}(L) = (Q, \Sigma, \delta, q_0, Q
\setminus F)$ допускает дополнение $\overline L = \Sigma^\ast \setminus L$ языка
$L$, которое является, таким образом, регулярным языком.

Поскольку справедливо $L_1 \cap L_2 = \overline{\overline L_1 \cup \overline
L_2}$, то язык $L_1 \cap L_2$ регулярен, исходя из доказанного выше.
Аналогично регулярность операции взятия разности языков выводится из
равенства $L_1 \setminus L_2 = L_1 \cap \overline{L_2}$.
\end{myproof}

\begin{myproblem}
Задача построения конечного автомата, распознающего дополнение
языка, была сведена к взятию дополнения множества заключительных
состояний детерминированного автомата исходного языка. На самом деле, этот факт
требует отдельного доказательства, которое читателю предлагается
построить самостоятельно. Неожиданным является то, что для
недетерминированного автомата исходного языка
такая конструкция в общем случае не
работает. Приведите контрпример, иллюстрирующий эту проблему.
\end{myproblem}

\begin{myproblem}
Доказательство регулярности $L_1 \cap L_2$ можно провести
конструктивно, а не формально, как это было сделано с помощью
определения операции пересечения через дополнение и разность.
А именно, имеется явная схема для ДКА, допускающего $L_1 \cap L_2$,
внутри которой «параллельно» работают автоматы $\mathcal A(L_1)$
и $\mathcal A(L_2)$ для языков $L_1$ и $L_2$. Попытайтесь придумать эту
схему или разберите теорему~4.8 раздела~4.2.1 учебника~\cite{Hop}.
\end{myproblem}

\begin{myproblem}
\textbf{(Контрпример к достаточности леммы о накачке.)}
Необходимо понимать, что условие леммы о накачке не является
достаточным для регулярности языка. То есть, если
некоторый язык ему удовлетворяет, из этого не следует
регулярность языка. Рассмотрим язык
\[L = \{a^i b^j c^k \mid i, j, k \in \N_0 \wedge (i=1 \Rightarrow j = k)\}.\]
Покажите, что
\begin{enumerate}
    \item $L$ нерегулярен (с помощью свойства замкнутости),
    \item $L$ удовлетворяет условию леммы о накачке.
\end{enumerate}
\end{myproblem}

Пусть $\Sigma$ --- конечный алфавит, $\Sigma^*$ --- полный язык над 
алфавитом $\Sigma$. Выделим регулярные подмножества $L_1, L_2 \subseteq 
\Sigma^*$. Если $L_1, L_2$ --- регулярные языки над алфавитом $\Sigma$, 
то регулярными являются следующие языки:
\begin{multicols}{3}
\begin{enumerate}
\item $L_1 \cup L_2$
\item $L_1 L_2$
\item $L_1^*$
\item $L_1^R = \{ \omega^R \mid \omega \in L_1 \}$
\item $\bar L_1 = \Sigma^* \setminus L_1$
\item $L_1 \cap L_2$
\item $L_1 \setminus L_2$
\item $H(L_1)$
\item $H^{-1}(L_1)$
\end{enumerate}
\end{multicols}

Язык регулярен, если можно построить конечный автомат, распознающий 
этот язык. Пункты $1, 2, 3$ подробно рассматривались и доказывались в 
разделе~\ref{Chapter3MathesFARL}. Построим конечные автоматы для языков 
из пунктов $4, 5, 6, 7$.

Рассмотрим язык $L_1^R = \{ \omega^R \mid \omega \in L_1 \}$, 
полученный \emph{обращением} языка $L_1$ (пункт $4$). Поскольку язык 
$L_1$ --- регулярный, для него существует конечный автомат. Пусть $M_1 
= (Q,\Sigma, \delta, q_0, F)$ --- конечный автомат, у которого $L(M_1) 
= L_1$. Построим конечный автомат $M^R = (Q_R, \Sigma, \delta^R, F^R)$ 
следующим образом:
%
\begin{enumerate}

\item Если $\mid F \mid > 1$, то ввести новое финальное состояние 
$q_f$. Из каждого старого финального состояния $p \in F$ ввести 
$\eps$-переход в новое финальное состояние. Положить $F = \{ q_f \}$.

\item Обратить все стрелки диаграммы переходов автомата $M$.

\item Положить $q_R = q_f$, $F^R = \{ q_0 \}$.

\end{enumerate}
%
Построенный таким образом автомат $M^R$ начинает распознавать цепочку с 
последней буквы и входит в допускающее состояние после прочтения первой 
буквы.

Проверим, что результат обращения регулярного языка в алфавите $\Sigma$ 
также является регулярным языком:
\begin{enumerate}
\item $\{ \es \}^R = \{ \es \} $, $\{ \eps \}^R = \{ \eps \} $, $\{ a \}^R = \{ a \} \forall a \in \Sigma $.
\item $(L_1 \cup L_2)^R = (L_{1}^R \cup L_{2}^R)$.
\item $(L_1 L_2)^R = (L_{1}^R L_{2}^R)$.
\item $(L_{1}^*)^R = \{ \eps \}^R \cup (L_1)^R \cup (L_2)^R \ldots (L_{1}^R)^*$.
\end{enumerate}

\input{img/chap5/aut-graph-12}
\input{img/chap5/aut-graph-13}

\begin{myexample}\label{ex-511}
Пусть $L = 01^*0^*$. Диаграмма автомата, 
распознающего язык $L$, приведена на рисунке~\ref{aut-graph-12}. В 
автомате два допускающих состояния: $q_1$ и $q_2$. Сведём эти состояния в 
одно новое допускающее состояние $q_f$, добавив $\eps$-переходы. 
Диаграмма конечного автомата, допускающего язык-обращение $L^R = 0^*1^*0$ 
представлена на рисунке~\ref{aut-graph-13}.
\end{myexample}

Рассмотрим язык $\bar L_1$ (пункт $5$). Поскольку язык $L_1$~--- 
регулярный, для него существует конечный автомат. Пусть $M_1 = 
(Q,\Sigma, \delta, q_0, F)$ --- полностью определённый ДКА, у которого 
$L(M_1) = L_1$. Рассмотрим конечный автомат $\bar M_1 = (Q,\Sigma, 
\delta, q_0, Q \setminus F)$. Автомат $\bar M_1$ определяется такой же 
$\delta$-функцией, что и $M_1$, т. е. их поведение одинаково. Возьмём 
произвольную цепочку $\omega \in L_1$. Для неё справедливо следующее: 
\[ (q_0, \omega) \vdash_{M_1}^* (q_f, \eps), q_f \in F \] В то же время 
в автомате $\bar M_1$ для этой цепочки выполняется следующее: \[ (q_0, 
\omega) \vdash_{\bar M_1}^* (q_f, \eps), q_f \in (Q \setminus F) \] 
Отсюда следует, что если произвольная цепочка допускается в $M_1$, то в 
автомате $\bar M_1$ эта цепочка приводит к недопускающему состоянию. 
Таким образом $L(\bar M_1) = \bar L_1$ --- регулярный язык. 

\input{img/chap5/aut-graph-14}

\begin{myexample}\label{ex-513}
Пусть $L = 01^*0$. Диаграмма автомата, распознающего 
язык $L$, приведена на рисунке~\ref{aut-graph-14}. Представленный ДКА 
не полностью определён. Идея инвертирования конечного автомата 
заключается в том, чтобы все недопускающие состояния стали допускающими 
и наоборот, а в неполностью определенных ДКА дан не весь набор 
состояний, в который автомат может перейти. Иными словами, в полностью 
определённых конечных автоматах заложено описание как распознаваемого 
языка, так и дополнения к нему, а в неполностью определённых --- только 
описание распознаваемого языка.

\input{img/chap5/aut-graph-15}

Доопределим ДКА на рисунке~\ref{aut-graph-14} следующим образом: введём 
новое недопускающее состояние $q_E$ и добавим недостающие переходы в 
это состояние. Получившийся полностью определённый ДКА представлен на 
рисунке~\ref{aut-graph-15}. Теперь инвертируем состояния и получим ДКА 
(рисунок~\ref{aut-graph-16}), распознающий язык $\bar L = \eps + 1(0 + 
1)^* + 01^*(\eps + 0(0+1)(0+1)^*)$ 
\end{myexample}

\input{img/chap5/aut-graph-16}

Рассмотрим язык $L = L_1 \cap L_2$ (пункт $6$). Поскольку языки $L_1, L_2$ --- регулярны, для них существуют конечные автоматы. Пусть $M_1 = (Q_1,\Sigma, \delta_1, q_1, F_1)$ --- ДКА, у которого $L(M_1) = L_1$. $M_2 = (Q_2,\Sigma, \delta_2, q_2, F_2)$ --- ДКА, у которого $L(M_2) = L_2$.

Построим конечный автомат
\begin{align*}
M &= (Q_1 \times Q_2,\Sigma, \delta, (q_1, q_2), F_1 \times F_2),\text{ где}\\
\delta:& \forall a \in \Sigma, \forall p \in Q_1, \forall q \in Q_2 \delta((p, q), a) = (\delta_1(p,a), \delta_2(q,a)).
\end{align*}
Покажем, что данный автомат распознаёт $L_1 \cap L_2$.

Произвольная цепочка
\[\omega \in L(M) 
    \Leftrightarrow 
    ((q_1, q_2), \omega) \vdash_{M}^* ((q_{f_1}, q_{f_2}), \eps), q_{f_1} \in F_1, q_{f_2} \in F_2.\] 
Вместе с этим 
\begin{align*}
  (q_1, \omega) &\vdash_{M_1}^* (q_{f_1}, \eps),  q_{f_1} \in F_1, \\
  (q_2, \omega) &\vdash_{M_2}^* (q_{f_2}, \eps), q_{f_2} \in F_2.
\end{align*}
Таким образом, цепочка допускается автоматом $M$, если она одновременно допускается и автоматом $M_1$, и автоматом $M_2$.

\begin{myexample}
Пусть
\begin{align*}
L_1 &= a^*bc 
    & M_1 &= (\{q_0; q_1; q_f\}, \{ a; b; c \}, \delta_1, q_0, \{ q_f \}) \\
L_2 &= b^*ca^* 
    & M_2 &= (\{p_0; p_f\}, \{ a; b; c \}, \delta_2, p_0, \{ p_f \}).
\end{align*}
где $\delta_1$ и $\delta_2$ определены как показано на рисунке~\ref{fig-ex-5.1.3}.

\begin{figure}[t]
\centering
     \begin{tabular}{rlll}
     \toprule
     \multirow{2}{*}{\Large $\delta_1$}
      & \multicolumn{3}{c}{\text{Вход}} \\
    \cmidrule(rll){2-4}
        & \multicolumn{1}{c}{a}
				& \multicolumn{1}{c}{b}
        &\multicolumn{1}{c}{c}\\
     \midrule
     ${}\to q_0$ & $\{q_0\}$ & $\{ q_1 \}$ & $\emptyset$\\
     $q_1$ & $ \emptyset $ & $\emptyset$ & $\{ q_f \}$\\
     $\boxed{q_f}$ & $\emptyset$ & $\emptyset$ & $\emptyset$\\
     \bottomrule
    \end{tabular}
%\vskip
\hspace{4 em}
%\bigskip
     \begin{tabular}{rlll}
     \toprule
     \multirow{2}{*}{\Large $\delta_2$}
      & \multicolumn{3}{c}{\text{Вход}} \\
    \cmidrule(rll){2-4}
        & \multicolumn{1}{c}{a}
				& \multicolumn{1}{c}{b}
        &\multicolumn{1}{c}{c}\\
     \midrule
     ${}\to p_0$ & $\emptyset$ & $\{ p_0 \}$ & $\{ p_f \}$\\
     $\boxed{p_f}$ & $\{ p_f \}$ & $\emptyset$ & $\emptyset$\\
     \bottomrule
    \end{tabular}
\caption{}
\label{fig-ex-5.1.3}
\end{figure}

Построим новую таблицу функции переходов для автомата, распознающего пересечение исходных языков,
как показано на рисунке~\ref{fig-ex-5.1.3-res} (с.~\pageref{fig-ex-5.1.3-res}). Таким образом 
\[ M = (\{ (q_0, p_0); (q_1, p_0); (q_f, p_f)  \}, \Sigma, \delta, (q_0, p_0), \{ (q_f, p_f)  \}. \] 
Язык $L(M) = \{bc \}.$
\end{myexample}

\begin{figure}[t]
\centering
    \begin{tabular}{rlll}
     \toprule
     \multirow{2}{*}{\Large $\delta$}
      & \multicolumn{3}{c}{\text{Вход}} \\
    \cmidrule(rll){2-4}
        & \multicolumn{1}{c}{a}
				& \multicolumn{1}{c}{b}
        &\multicolumn{1}{c}{c}\\
     \midrule
     ${}\to (q_0, p_0)$ & $ \{ (q_0, \es) \} $ & $ \{ (q_1, p_0) \} $ & $ \{ (\es, p_1) \} $\\
		 $(q_1, p_0)$ & $ \{ (\es, \es) \} $ & $ \{ (\es, p_0) \} $ & $ \{ (q_f, p_f) \} $\\
     $\boxed{(q_f, p_f)}$ & $\{ (\es, p_1) \}$ & $(\es, \es)$ & $(\es, \es)$\\
     \bottomrule
    \end{tabular}
\caption{}
\label{fig-ex-5.1.3-res}
\end{figure}

Рассмотрим язык $L = L_1 \setminus L_2$ (пункт $7$). Поскольку $L_1$ и 
$L_2$ --- множества (регулярные), то теоретико-множественная операция 
разности может быть выражена через другие операции следующим образом: 
$L = L_1 \setminus L_2 = L_1 \cap \bar L_2$. В пунктах $5, 6$ показано, 
как строить автоматы для операций дополнения и пересечения, так что 
построение автомата для разности двух регулярных выражений заключается 
в построении автомата, распознающего дополнение к языку $L_2$, и 
построении автомата, распознающего пересечение между $L_1$ и 
дополнением к $L_2$.

\begin{figure}
\begin{subfigure}[b]{.5\linewidth}
\centering
\begin{tikzpicture}[node distance=3cm,>=stealth',auto,every state/.style={thick}]
	\node (init) {};
	\node[state, accepting] (q_0) [right=.7cm of init] {$q_0$};
    \node[state] (q_1) [right of=q_0] {$q_1$};
	\node[state] (q_2) [right of=q_1] {$q_2$};
    \node[state, accepting] (q_E) [below of=q_1] {$q_E$};
    
	\path[->]
    	(init) edge (q_0)
        (q_0) edge node {$a$} (q_1)
        (q_0) edge node {$b, c$} (q_E)
        (q_1) edge [loop above] node {$b$} (q_1)
        (q_1) edge node {$c$} (q_2)
        (q_1) edge node {$a$} (q_E)
		(q_2) edge [loop above] node {$c$} (q_2)
		(q_2) edge node {$a, b$} (q_E)
		(q_E) edge [loop right] node {$a, b, c$} (q_E);
\end{tikzpicture}
\caption{Язык $\bar L_2$}
\label{aut-graph-17}
\end{subfigure}%
\begin{subfigure}[b]{.5\linewidth}
\centering
\begin{tikzpicture}[node distance=3cm,>=stealth',auto,every state/.style={thick}]
	\node (init) {};
	\node[state] (p_0) [right=.7cm of init] {$p_0$};
    \node[state] (p_1) [right of=p_0] {$p_1$};
	\node[state, accepting] (p_2) [below of=p_1] {$p_2$};
    
	\path[->]
    	(init) edge (p_0)
        (p_0) edge [loop above] node {$a$} (p_0)
        (p_0) edge node {$b$} (p_1)
        (p_0) edge node {$c$} (p_2)
        (p_1) edge [loop above] node {$b$} (p_1)
        (p_1) edge node {$c$} (p_2);
\end{tikzpicture}
\caption{Язык  $L_1$}\label{aut-graph-18}
\end{subfigure}
\caption{Два ДКА для примера \ref{ex-514}}
\end{figure}

\begin{myexample}\label{ex-514}
Пусть $L_1 = a^*b^*c$, $L_2 = ab^*c^*$. Построим конечный автомат 
$M_{\bar L_2}$, такой что $L(M_{\bar L_2}) = \bar L_2$. Для этого 
необходимо построить конечный автомат, распознающий язык $L_2$, 
доопределить его, если это необходимо, и инвертировать состояния. 
Диаграмма автомата, распознающего язык $\bar L_2$, приведена на 
рисунке~\ref{aut-graph-17}.

Построим автомат, распознающий язык $L_1$. Поскольку он будет 
использоваться для построения автомата, распознающего пересечение 
языков, этот автомат доопределять не будем. Диаграмма автомата, 
распознающего язык $L_2$, приведена на рисунке~\ref{aut-graph-18}.

Для построения автомата, распознающего $L_1 \cap \bar L_2$, 
воспользуемся таблицами $\delta$-функций переходов автоматов для языка 
$L_1$ и $\bar L_2$ (рисунок~\ref{reg-langs-dif}, с.~\pageref{reg-langs-dif}).

\begin{figure}
     \centering
     \begin{tabular}{rlll}
     \toprule
     \multirow{2}{*}{\Large $\delta_{L_1}$}
      & \multicolumn{3}{c}{\text{Вход}} \\
    \cmidrule(rll){2-4}
        & \multicolumn{1}{c}{a}
				& \multicolumn{1}{c}{b}
        &\multicolumn{1}{c}{c}\\
     \midrule
     ${}\to p_0$ & $\{p_0\}$ & $\{ p_1 \}$ & $\{ p_2 \}$\\
     $p_1$ & $ \emptyset $ & $\{ p_1 \}$ & $\{ p_2 \}$\\
     $\boxed{p_2}$ & $\emptyset$ & $\emptyset$ & $\emptyset$\\
     \bottomrule
    \end{tabular}	
\hspace{4 em}
%\bigskip
     \begin{tabular}{rlll}
     \toprule
     \multirow{2}{*}{\Large $\delta_{\bar L_2}$}
      & \multicolumn{3}{c}{\text{Вход}} \\
    \cmidrule(rll){2-4}
        & \multicolumn{1}{c}{a}
				& \multicolumn{1}{c}{b}
        &\multicolumn{1}{c}{c}\\
     \midrule
     ${}\to q_0$ & ${ q_1 }$ & $\{ q_E \}$ & $\{ q_E \}$\\
		 $q_1$ & ${ q_E }$ & $\{ q_1 \}$ & $\{ q_2 \}$\\
		 $q_2$ & ${ q_E }$ & $\{ q_E \}$ & $\{ q_2 \}$\\
     $\boxed{p_E}$ & $\{ p_E \}$ & $\{ p_E \}$ & $\{ p_E \}$\\
     \bottomrule
    \end{tabular}
    \caption{}
    \label{reg-langs-dif}
\end{figure}

На основе построенных таблиц сформируем новую таблицу функции переходов 
для автомата, распознающего язык $L_1 \cap \bar L_2$ 
(рисунок~\ref{reg-langs-dif-res}, с.~\pageref{reg-langs-dif-res}).

\begin{figure}
    \centering
    \begin{tabular}{rlll}
     \toprule
     \multirow{2}{*}{\Large $\delta_{L_1 \cap \bar L_2}$}
      & \multicolumn{3}{c}{\text{Вход}} \\
    \cmidrule(rll){2-4}
        & \multicolumn{1}{c}{a}
				& \multicolumn{1}{c}{b}
        &\multicolumn{1}{c}{c}\\
     \midrule
     ${}\to A = (q_0, p_0)$ & $ \{ (q_1, p_1) \} $ & $ \{ (q_E, p_2) \} $ & $ \{ (q_E, p_3) \} $\\
		 $B = (q_1, p_1)$ & $ \{ (q_E, p_1) \} $ & $ \{ (q_1, p_2) \} $ & $ \{ (q_2, p_3) \} $\\
		 $C = (q_E, p_2)$ & $ \{ (q_E, \es) \} $ & $ \{ (q_E, p_2) \} $ & $ \{ (q_E, p_3) \} $\\
		 $\boxed{D =(q_E, p_3)}$ & $ \{ (q_E, \es) \} $ & $ \{ (q_E, \es) \} $ & $ \{ (q_E, \es) \} $\\
		 $E = (q_E, p_1)$ & $ \{ (q_E, p_1) \} $ & $ \{ (q_E, p_2) \} $ & $ \{ (q_E, p_3) \} $\\
		 $F = (q_1, p_2)$ & $ \{ (q_E, \es) \} $ & $ \{ (q_1, p_2) \} $ & $ \{ (q_2, p_3) \} $\\
		 $G = (q_2, p_3)$ & $ \{ (q_E, \es) \} $ & $ \{ (q_E, \es) \} $ & $ \{ (q_E, \es) \} $\\
     \bottomrule
    \end{tabular}
    \caption{}
    \label{reg-langs-dif-res}
\end{figure}

Диаграмма автомата $M$, распознающего $L_1 \cap \bar L_2$, представлена 
на рисунке~\ref{aut-graph-19} (с.~\pageref{aut-graph-19}).

\input{img/chap5/aut-graph-19}

Вычислив язык автомата $M$ методом исключения состояний, можно убедиться, что 
\[L(M) = c+bc+aaa^*(c+bc)+(ab+bb+aaa^*bb)(bb)^*bc.\]
\end{myexample}

\begin{myproblem}
Пусть $L_1, L_2$ --- регулярные языки над алфавитом $\Sigma$. Покажите, что языки $H(L_1)$ и $H^{-1}(L_1)$ являются регулярными.
\end{myproblem}

\section{Замкнутость регулярных множеств относительно базисных операций}
\label{Chapter5Closure}

Рассматривая свойства регулярных языков, мы получили инструкции построения конечных автоматов, распознающих языки --- результаты операций над регулярными множествами. Регулярные множества обладают еще одним важным свойством, которое позволяет определять произвольные операции над языками и строить конечные автоматы для их распознавания.

Напомним, что множество $A$ называется замкнутым относительно $n$-местной операции $\Psi$, если $\Psi(a_1, a_2, \ldots a_n) \in A \forall a_i \in A, 1 \leq i \leq n $. Так, например, множество натуральных чисел замкнуто относительно операции сложения. 

\textbf{\textit{Определение:}} Класс множеств называется булевой алгеброй множеств, если он замкнут относительно дополнения, объединения и пересечения.

\begin{mytheorem}
Пусть $\Sigma$ --- произвольный (необязательно конечный) алфавит. Класс регулярных множеств, содержащихся в $\Sigma^*$, является булевой алгеброй множеств.
\end{mytheorem}
\begin{myproof}
Замкнутость относительно объединения уже доказывалась ранее. Замкнутость относительно пересечения следует из теоретико-множественного закона $\overline{\overline{ A \cap B }} = \overline {\bar A \cup \bar B}$.

Докажем замкнутость относительно дополнения. Пусть $M = (Q, \Delta, \delta, q_0, F)$ --- конечный автомат, у которого $\Delta \subseteq \Sigma$, $\Delta$ --- конечный алфавит. Легко показать, что каждое регулярное множество $L \subseteq \Sigma^* $ допускается некоторым таким автоматом. Тогда конечный автомат $M' = (Q, \Delta, \delta, q_0, Q \setminus F)$ допускает $\Delta^* \setminus L(M)$. При этом автомат $M$ должен быть полностью определён. 

Дополнение $\overline {L(M)}$ относительно $\Sigma^*$ можно представить в виде 
\[
\overline {L(M)} = L(M') \cup \Sigma^*(\Sigma \setminus \Delta)\Sigma^*
\]
Так как множество $\Sigma^*(\Sigma \setminus \Delta)\Sigma^*$ регулярно, то регулярность множества $L(M)$ следует из замкнутости регулярных множеств относительно объединения.
\end{myproof}

Из свойства замкнутости регулярных множеств относительно базисных операций дополнения, объединения и пересечения следует, в частности, что произвольные конечные комбинации этих операций также являются регулярными множествами, и через базисные операции можно вывести любые другие операции над регулярными множествами.

\section{Алгоритмические проблемы регулярных языков}
\label{Chapter5AlgProblems}
Регулярный язык может быть задан конечным образом с помощью трех типов описаний: праволинейной грамматики, регулярного выражения или конечного автомата. Имея одно описание, можно перейти к любому другому с помощью известных алгоритмов.

Для конечных описаний регулярных множеств естественным образом возникают алгоритмические проблемы. Рассмотрим три из них.
\begin{enumerate}
\item \textit{Проблема принадлежности:} Дано конечное описание языка и цепочка $w$. Принадлежит ли цепочка $w$ этому языку?
\item \textit{Проблема пустоты:} Дано конечное описание языка. Пуст ли этот язык?
\item \textit{Проблема эквивалентности:} Даны два конечных описания языка одного типа. Задают ли эти описания один и тот же язык?
\end{enumerate}
Поскольку для каждого типа описания можно построить эквивалентное ему описание другого типа, то достаточно рассмотреть решение этих проблем только для одного типа описания. Будем рассматривать решения обозначенных алгоритмических проблем для конечных автоматов.

\textit{Проблема принадлежности для конечных автоматов} решается с 
помощью следующего алгоритма. На вход алгоритм получает конечный 
автомат $M = (Q,\Sigma, \delta, q_0, F)$ и цепочку $w \in \Sigma^*$. На 
выходе алгоритм возвращает ответ <<ДА>>, если $w \in L(M)$, в противном 
случае возвращается ответ <<НЕТ>>. Принцип работы алгоритма следующий.

Пусть $w = a_1a_2 \ldots a_n$. Найти последовательно состояния
\[q_1 = \delta(q_0, a_1), \quad q_2 = \delta(q_1, a_2), \quad\ldots ,\quad q_n = 
\delta(q_{n-1}, a_n).\] 
Если $q_n \in F$, вернуть <<ДА>>. В противном 
случае вернуть <<НЕТ>>. Иными словами, задача алгоритма --- определить 
достижимость любого финального состояния из начального по заданной 
цепочке.

Шаги алгоритма:
\begin{enumerate}
\item  Представить $w = a_1a_2 \ldots a_n$. Если $n = 0$, перейти к Шагу 5.
\item Положить $i = 0$.
\item $q_{i+1} = \delta(q_i, a_{i+1})$.
\item Если $ i \neq n$, $ i = i + 1$ и перейти к Шагу 2.
\item Если $q_i \in F$, вернуть <<ДА>>, иначе вернуть <<НЕТ>>.
\end{enumerate}

\textit{Проблема пустоты языка} конечного автомата $M = (Q,\Sigma, \delta, q_0, F)$ решается путём определения множества состояний, достижимых из $q_0$. Если хотя бы одно финальное состояние принадлежит этому множеству, то алгоритм возвращает ответ <<ДА>>, иначе --- <<НЕТ>>.

Шаги алгоритма:
\begin{enumerate}
\item Положить $Q_0 = { q_0 }, i = 1$.
\item $Q_i = $ {$p \in Q \vdash \forall a \in \Sigma \delta(q, a) = $ {$ p $} $, q \in Q_{i-1},$}.
\item Если $Q_i = Q_{i-1}$, $i = i + 1$ и перейти на Шаг 2.
\item Если $Q_i \cap F \neq \es$, вернуть <<ДА>>, иначе вернуть <<НЕТ>>.
\end{enumerate}

\textit{Проблема эквивалентности для конечных автоматов} может быть решена двумя способами. Первый способ --- это проверка симметрической разности двух исходных языков на непустоту.

Пусть $M_1 = (Q_1,\Sigma_1, \delta_1, q_1, F_1)$ и $M_2 = (Q_2,\Sigma_2, \delta_2, q_2, F_2)$ конечные автоматы, такие что $L_1 = L(M_1)$ и $L_2 = L(M_2)$. Симметрическая разность двух языков может быть построена через теоретико-логические операции:
\[ L_1 \triangle L_2 = (L_1 \setminus L_2) \cup(L_2 \setminus L_1) = (L_1 \cap \bar L_2) \cup (L_2 \cap \bar L_1). \]
В разделе $4.7$ показано, как построить конечные автоматы для результатов операций над регулярными языками. Далее с помощью алгоритма, решающего проблему пустоты языка, можно проверить, пуста ли полученная симметрическая разность. Если множество симметрической разности двух языков пусто, значит языки совпадают между собой. Следовательно, можно сделать вывод, что конечные автоматы, распознающие эти языки, эквивалентны.

Второй способ установления эквивалентности двух конечных автоматов основан на поиске неразличимых состояний в объединённом множестве состояний исходных автоматов. Изложим схему алгоритма установления экваиалентности двух автоматов.

Пусть $M_1 = (Q_1,\Sigma_1, \delta_1, q_1, F_1)$ и $M_2 = (Q_2,\Sigma_2, \delta_2, q_2, F_2)$ конечные автоматы, такие что $L_1 = L(M_1)$ и $L_2 = L(M_2)$. Построим конечный автомат $M_U = (Q_1 \cup Q_2, \Sigma_1 \cup \Sigma_2, q_1, F_1 \cup F_2)$. Поскольку автомат $M_U$ конструируется только для анализа, выбор начального состояния не имеет значения. Далее на множестве $Q_1 \cup Q_2$ выделяются классы неразличимости состояний. Если начальные состояния исходных автоматов находятся в оном классе эквивалентности, то алгоритм возвращает ответ <<ДА>>, иначе --- <<НЕТ>>.

\section{Упражнения}
\label{Chapter5Exs}
\subsection*{Свойства регулярных языков}
Построить регулярные выражения для множеств $L_1 \setminus L_2$, $L_1^R$, $L_1 \cup L_2$, $L_1 \triangle L_2$, если языки  $L_1$ и $L_2$ заданы следующими регулярными выражениями:
\begin{enumerate}
\item $L_1 = a^*b(a+b)^*$ и $L_2 = a^*b(a+b)^*$
\item $L_1 = (00 + 11)^*10(1 + 0)^*$ и $L_2=(00)^*(11)^*0^*1^*$
\end{enumerate}

\subsection*{Доказательство нерегулярности языков}
Пользуясь свойством замкнутости
класса регулярных языков, выяснить, какие из следующих языков регулярны:
%\begin{multicols}{2}
\begin{enumerate}
  \item $\{0^n 1^m \mid n \neq m\}$ (подсказка: воспользуйтесь
  нерегулярностью $\{0^n1^n\}$);
  \item $\{ w \in \{0, 1\}^* \mid
  |w|_0 = |w|_1\}$;
  \item язык из слов $w \in \{0,\ldots, 9\}^*$, которые
  являются десятичной записью чисел, делящихся на 2 или на 3, без
  лишних лидирующих нулей;
  \item $\{ 0^n 1^m 2^{n-m} \mid n \geqslant m \}$;
  \item $\{ a^n b a^m b a^{n+m} \mid n, m \in \N \}$.
\end{enumerate}
%\end{multicols}
%\subsection*{Удаление бесполезных символов}
%
%Удалить бесполезные символы в грамматиках с продукциями:
%\begin{align*}
    %\text{(1) }&
        %\begin{aligned}%{l}
            %S &\to 0 \mid A,\\
            %A &\to AB,\\
            %B &\to 1;
        %\end{aligned}
        %\qquad\qquad
    %&
    %\text{(2) }&
        %\begin{aligned}%{l}
            %S &\to AB \mid CA,\\
            %A &\to a,\\
            %B &\to BC \mid AB,\\
            %C &\to aB \mid \varepsilon.
        %\end{aligned}
%\end{align*}
